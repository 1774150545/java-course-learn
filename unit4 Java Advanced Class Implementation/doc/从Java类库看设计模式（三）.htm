<html><head><title>从Java类库看设计模式（三）</title><meta http-equiv=Content-Type content='text/html; charset=GB2312'><meta name='keywords' content='免费Java教程下载,Java电子书籍,Java技术文章,Java开发工具,设计模式'><link href='/style.css' rel=stylesheet type=text/css><style>TD {FONT-SIZE: 13px; COLOR: #646464; TEXT-DECORATION: none; FONT-FAMILY: 宋体}</style><script>function fontZoom(size){document.getElementById('fontzoom').style.fontSize=size+'px'}</script></head><body><TABLE cellSpacing=0 cellPadding=0 width=751 align=center border=0>  <TBODY>    <TR><TD><IMG height=75 src='images/u_11.gif' width=751></TD></TR>    <TR><TD vAlign=top background=images/u_bg.gif><BR>    <div align=right>页面功能&nbsp;      【<a href="javascript:window.external.AddFavorite(location.href,document.title+'－－www.JavaFan.NET');">加入收藏</a>】      【<a href='/sendarticle.jsp?title=从Java类库看设计模式（三）&URL=20051105083932433' onclick="window.open(this.href,'','top=180,left=240,width=342,height=326,scrollbars=yes,resizable=no');return false;">推荐给朋友</a>】      【字体：<a href="javascript:fontZoom(15)" class=black>大</a>&nbsp;<a href="javascript:fontZoom(13)" class=black>中</a>&nbsp;<a href="javascript:fontZoom(12)" class=black>小</a>】      【<a href="javascript:window.close()" class=black>关闭</a>】&nbsp;&nbsp;&nbsp;    </div>    <TABLE cellSpacing=0 cellPadding=0 width=740 align=center border=0>      <TBODY><TR><TD vAlign=top align=right>        <TABLE cellSpacing=0 cellPadding=0 width=730 border=0>          <TBODY><TR><TD><IMG height=11 src='images/u_14.gif' width=10></TD>          <TD style='BORDER-TOP: #e8e8e8 1px solid' bgColor=#f9f9f9><IMG height=1 src='' width=1></TD>          <TD><IMG height=11 src='images/u_15.gif' width=10></TD>          <TD vAlign=top width=8 rowSpan=3><BR><IMG height=136 src='images/u_13.gif' width=8></TD></TR>          <TR><TD style='BORDER-RIGHT: #e8e8e8 1px solid; BORDER-LEFT: #e8e8e8 1px solid' align=middle bgColor=#f9f9f9 colSpan=3>            <TABLE style='WORD-BREAK: break-all' cellSpacing=0 cellPadding=0 width=700 align=center border=0>              <TBODY>                <TR><TD align=middle height=25><FONT face=黑体 size=4>从Java类库看设计模式（三）</FONT></TD></TR>                <TR bgcolor=#F9F9F9><TD style='LINE-HEIGHT: 200%' id='fontzoom'>                  <P align=center>作者：刘武东&nbsp;&nbsp;&nbsp;&nbsp;来自：IBM</P>                     <P>　　上一次主要介绍了几个创建型的设计模式AbstractFactroy，FactoryMethod和Singliton。它们的共同的特点，都是用来创建对象的。这次接下来的内容，涉及到的是几个结构型的模式。所谓结构型模式，就是用来解决在创建系统结构的过程中，通过对类或者对象进行合理有效的组合，以获得更大的结构的方法。这儿主要讲到了Bridge模式和Decorator模式。对于Bridge模式可能需要更多的理解，因为它在很大程度上说，例示了设计模式的基本的设计思路和原则。</P>
<P>　　<STRONG>Bridge模式</STRONG></P>
<P>　　当初Java刚刚推出来的时候，AWT可是一个比较热的话题，虽然现在有被Swing取代的趋势。但是我一直都觉得AWT也有其优势，至少它使用的本地代码就要比Swing快上许多，而且，可以为用户提供熟悉的本地操作系统界面。如果在Windows XP中运行基于AWT的程序的话，XP中绚烂多变的界面Theme可以轻易应用到AWT程序中，而Swing就不行了，因为AWT所调用的是本带代码，使用的是本地的窗体控件。当然，Swing也有其好处，不可一概而论。</P>
<P>　　简单来讲，AWT提供对程序员的是对窗体界面系统的抽象，而在内部实现中，针对每一种操作系统，分别有不同实现，这就是同位体（Peer）的概念。当程序员调用AWT对象时，调用被转发到对象所对应的一个Peer上，在由Peer调用本地对象方法，完成对象的显示。例如，如果你使用AWT创建了一个Menu类的实例，那么在程序运行时会创建一个菜单同位体的实例，而由创建的同位体的来实际执行菜单的现实和管理。不同的系统，有不同的同位体实现，Solaris JDK将产生一个Motif菜单的同位体，Windows下的JDK将产生一个Windows的菜单的同位体，等等。同位体的使用，使得交叉平台窗口工具的开发变得极为迅速，因为同位体的使用可以避免重新实现本地窗口控件中已经包含的方法。</P>
<P align=center><IMG src="http://www.javafan.net/uploadfiles/20051105083302627.gif"><BR>图九：AWT中的组件和其对等体</P>
<P>　　实际上，从设计的角度来看，这是一个抽象和实现分离的过程--AWT是抽象，同位体是实现，抽象和实现各自成为一个对象体系，它们由一个桥连接起来，可以各自发展各自的对象层次，而不必顾虑另一方面。这就是Bridge模式所提供的思想。Bridge模式更可以提供在各个不同的实现中动态的进行切换，而不必从新编译程序。</P>
<P>　　通常，Bridge模式和AbstractFactory模式一起工作，由AbstractFactory来创建一个具体实现的对象体系。特殊的，当只有一个实现的时候，可以将Implementor抽象类去掉。这样，在抽象和实现之间建立起了一一对应的关系，但这并不损害Bridge模式的内涵。这被称为退化了的Bridge模式。</P>
<P>　　很多时候，Abstraction层次和Implementor层次之间的方法都不是一一对应的，也就是说，在Abstraction和Implementor之不是简单的的消息转发。通常，我们会将Abstraction作为一个抽象类（而不是接口）来实现。在Implementor层次中定义底层的，或者称之为原子方法，而在Abstraction层次中定义一些中高层的基于原子方法的抽象方法。这样，就能更为清晰的划分Abstraction和Implementor，类的结构也更为清晰。</P>
<P align=center><IMG src="http://www.javafan.net/uploadfiles/20051105083425227.gif"><BR>图十：Bridge模式对系统的划分</P>
<P>　　下面，我们来看一个Bridge模式的具体应用。考虑这样的一个问题，需要生成一份报告，但是报告的格式并没有确定，可能是HTML文件，也可能是纯ASCII文本。报告本身也可能分为很多种，财务报表，货物报表，等等问题很简单，用继承也较容易实现，因为相互之间的组合关系并不是很多。但是，我们现在需要用Bridge的观点来看问题。</P>
<P>　　在Bridge模式中，使用一个Report类来描叙一个报告的抽象，用一个Reporter类来描叙Report的实现，它的子类有HTMLReporter和ASCIIReporter，用来分别实现HTML格式和ASCII格式的报告。在Report层次下面，有具体的一个StockListReport子类，用来表示货物清单报告。</P>
<P style="BACKGROUND: #dddddd">public abstract class Report<BR>{<BR>&nbsp;&nbsp;&nbsp; Reporter reporter;<BR>&nbsp;&nbsp;&nbsp; public Report(Reporter reporter) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.reporter = reporter;<BR>}<BR>//抽象类使用桥接对象的方法来实现一个任务<BR>&nbsp;&nbsp;&nbsp; public void addReportItem(Object item){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reporter.addLine(item.toString());<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; public void addReportItems(List items){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Iterator iterator = items.iterator();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while ( iterator.hasNext() )<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reporter.addLine(iterator.next().toString());<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; public String report(){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return reporter.getReport();<BR>&nbsp;&nbsp;&nbsp; }<BR>}<BR><BR>public class StockListReport extends Report{<BR>&nbsp;&nbsp;&nbsp; ArrayList stock=new ArrayList();<BR>&nbsp;&nbsp;&nbsp; public StockListReport(Reporter reporter){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super(reporter);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; public void addStockItem(StockItem stockItem){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stock.add(stockItem);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addReportItem(stockItem);<BR>&nbsp;&nbsp;&nbsp; }<BR>}<BR><BR>//实现层次的抽象父类定义原子方法，供抽象层次的类调用<BR>public abstract class Reporter{<BR>&nbsp;&nbsp;&nbsp; String header = "";<BR>&nbsp;&nbsp;&nbsp; String trailer = "";<BR>&nbsp;&nbsp;&nbsp; String report = "";<BR>&nbsp;&nbsp;&nbsp; public abstract void addLine(String line);<BR>&nbsp;&nbsp;&nbsp; public void setHeader(String header){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.header = header;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; public void setTrailer(String trailer){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.trailer = trailer;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; public String getReport(){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return header+report+trailer;<BR>&nbsp;&nbsp;&nbsp; }<BR>}<BR><BR>public class HTMLReporter extends Reporter{&nbsp; <BR>&nbsp;&nbsp;&nbsp; public HTMLReporter(){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setHeader("&lt;HTML&gt;\n&lt;HEAD&gt;&lt;/HEAD&gt;\n&lt;BODY&gt;\n");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setTrailer("&lt;/BODY&gt;\n&lt;/HTML&gt;");<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; public void addLine(String line){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; report += line + "&lt;BR&gt;\n";<BR>&nbsp;&nbsp;&nbsp; }<BR>}<BR><BR>public class ASCIIReporter extends Reporter{<BR>&nbsp;&nbsp;&nbsp; public void addLine(String line) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; report += line + "\n";<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>　　实际上，Bridge模式是一个很强大的模式，可以应用在很多方面。其基本思想：分离抽象和实现，是设计模式的基础之一。正如GOF所提到的："找到变化的部分，并将其封装起来"；"更多的考虑用对象组合机制，而不是用对象继承机制"。Bridge模式很好的体现了这几点。</P>
<P>　　<STRONG>Decorator模式</STRONG></P>
<P>　　在使用Java中的IO类库的时候，是不是快要被它那些功能相似，却又绝对可称得上庞杂的类搞得要发疯了？或许你很不明白为什么要做这么多功能相似的几十个类出来，这就是Decorator模式将要告诉你的了。</P>
<P>　　在IO处理中，Java将数据抽象为流（Stream）。在IO库中，最基本的是InputStream和OutputStream两个分别处理输出和输入的对象（为了叙述简便起见，这儿只涉及字节流，字符流和其完全相似），但是在InputStream和OutputStream中之提供了最简单的流处理方法，只能读入/写出字符，没有缓冲处理，无法处理文件，等等。它们只是提供了最纯粹的抽象，最简单的功能。</P>
<P>　　如何来添加功能，以处理更为复杂的事情呢？你可能会想到用继承。不错，继承确实可以解决问题，但是继承也带来更大的问题，它对每一个功能，都需要一个子类来实现。比如，我先实现了三个子类，分别用来处理文件，缓冲，和读入/写出数据，但是，如果我需要一个既能处理文件，又具有缓冲功能的类呢？这时候又必须在进行一次继承，重写代码。实际上，仅仅这三种功能的组合，就已经是一个很大的数字，如果再加上其它的功能，组合起来的IO类库，如果只用继承来实现的话，恐怕你真的是要被它折磨疯了。</P>
<P align=center><IMG src="http://www.javafan.net/uploadfiles/20051105083925227.gif"><BR>图六：JDK中IO流的类层次</P>
<P>　　Decorator模式可以解决这个问题。Decorator字面的意思是装饰的意思，在原有的基础上，每添加一个装饰，就可以增加一种功能。这就是Decorator的本意。比如，对于上面的那个问题，只需要三个Decorator类，分别代表文件处理，缓冲和数据读写三个功能，在此基础上所衍生的功能，都可以通过添加装饰来完成，而不必需要繁杂的子类继承了。更为重要的是，比较继机制承而言，Decorator是动态的，可以在运行时添加或者去除附加的功能，因而也就具有比继承机制更大的灵活性。</P>
<P>　　上面就是Decorator的基本思想，下面的是Decorator模式的静态结构图：</P>
<P align=center><IMG src="http://www.javafan.net/uploadfiles/20051105083810815.gif"><BR>图七：Decorator模式的类图</P>
<P>　　可以看到，一个Decorator与装饰的Subject对象有相同的接口，并且除了接口中给出的方法外，每个Decorator均有自己添加的方法，来添加对象功能。每个Decorator均有一个指向Subject对象的引用，附加的功能被添加在这个Subject对象上。而Decorator对象本身也是一个Subject对象，因而它也能够被其他的Decorator所修饰，提供组合的功能。</P>
<P>　　在Java IO操作中，经常可以看到诸如如下的语句：</P>
<P style="BACKGROUND: #dddddd">　　myStringBuffer=new StringBuffer("This is a sample string to be read");<BR>　　FilterInputStream myStream=new LineNumberInputStream( new BufferInputStream( new StringBufferInputStream( myStringBuffer)));<BR>　　myStream.read();<BR>　　myStream.line();</P>
<P>　　多个的Decorator被层叠在一起，最后得到一个功能强大的流。既能够被缓冲，又能够得到行数，这就是Decorator的威力！</P>
<P>　　不仅仅如此，Java中的IO还允许你引入自定义的Decorator，来实现自己想要的功能。在良好的设计背景下，这做起并不复杂，只需要4步：</P>
<P>　　1. 创建两个分别继承了FilterInputStream和 FilterOutputStream的子类 <BR>　　2. 重载read()和write()方法来实现自己想要的功能。 <BR>　　3. 可以定义或者重载其它方法来提供附加功能。 <BR>　　4. 确定这两个类会被一起使用，因为它们在功能上是对称的。 </P>
<P>　　就这样，你就可以无限的扩展IO的功能了。</P>
<P>　　在了解了IO中的Decorator后，我们再来看一个Decorator模式应用的具体的例子。这个例子原本是出现在GOF书中的，这儿稍作改动，引来示例。</P>
<P>　　在一个图形用户界面（GUI）中，一个组件有时候需要用到边框或者滚动条，而有时候又不需要，有时候可能两者都要用到。当需要动态的去处或者添加职能的时候，就可以考虑使用Decorator模式了。这儿对于一个VisualComponent组件对象，我们引入了两个Decorator类：BoderDecorator和ScrollDecorator，分别用来为组件添加边框和处理滚动。程序类图如下：</P>
<P align=center><IMG src="http://www.javafan.net/uploadfiles/20051105083854604.gif"><BR>图八：Decorator模式的应用例子</P>
<P>　　程序写得很简单，没有包括具体的代码，只是有一个可以运行的框架以供参考。代码如下：</P>
<P style="BACKGROUND: #dddddd">//Client类用来创建窗体和组件对象，这儿可以看到Decorator是如何组合和应用的<BR>class Client{<BR>&nbsp;&nbsp; public static void main (String[] args ){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Window&nbsp;&nbsp; window&nbsp;&nbsp; = new Window ();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TextView textView = new TextView ();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; window.setContents (<BR>&nbsp;&nbsp;&nbsp;&nbsp; new BorderDecorator (<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new ScrollDecorator (textView, 500), 1));<BR>&nbsp;&nbsp; } <BR>}<BR>//Windows类用来容纳组件对象<BR>class Window{<BR>&nbsp;&nbsp; VisualComponent contents;<BR>&nbsp;&nbsp; public Window () {} <BR>&nbsp;&nbsp; public void setContents (VisualComponent vc){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; contents = vc;<BR>&nbsp;&nbsp; } <BR>}<BR>//VisualComponent类定义了组件的接口<BR>class VisualComponent{<BR>&nbsp;&nbsp; public VisualComponent (){}<BR>&nbsp;&nbsp; public void draw (){}<BR>&nbsp;&nbsp; public void resize (){}<BR>}<BR>//TextView类是一个显示文本的具体的组件<BR>class TextView extends VisualComponent{<BR>&nbsp;&nbsp; public TextView (){}<BR>&nbsp;&nbsp; public void draw (){<BR>&nbsp;&nbsp;&nbsp; …<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp; public void resize (){<BR>&nbsp;&nbsp;&nbsp; …<BR>&nbsp;&nbsp;&nbsp; }<BR>}<BR>//Decorator类继承于VisualComponent，定义所有Decorator的缺省方法实现<BR>class Decorator extends VisualComponent{<BR>&nbsp;&nbsp; private VisualComponent component;<BR>&nbsp;&nbsp; public Decorator (VisualComponent vc) {<BR>&nbsp;&nbsp;&nbsp; this.component=vc;<BR>&nbsp;&nbsp; }<BR>&nbsp;&nbsp; public void draw () {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; component.draw ();<BR>&nbsp;&nbsp; }<BR>&nbsp;&nbsp; public void resize () {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; component.resize ();<BR>&nbsp;&nbsp; }<BR>}<BR>//BorderDecorator类为组件提供边框<BR>class BorderDecorator extends Decorator{<BR>&nbsp;&nbsp; private int width;<BR>&nbsp;&nbsp; public BorderDecorator (VisualComponent vc, int borderWidth){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super (vc);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; width = borderWidth;<BR>&nbsp;&nbsp; }<BR>&nbsp;&nbsp; public void draw (){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super.draw ();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drawBorder (width);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp; private void drawBorder (int width){<BR>&nbsp;&nbsp;&nbsp; …<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>}<BR>//ScrollDecorator类为组件提供滚动条<BR>class ScrollDecorator extends Decorator{<BR>&nbsp;&nbsp; private int scrollSize;<BR>&nbsp;&nbsp; public ScrollDecorator (VisualComponent vc, int scrSize){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super (vc);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scrollSize = scrSize;<BR>&nbsp;&nbsp; }<BR>&nbsp;&nbsp; public void draw (){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scroll();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super.draw ();<BR>&nbsp;&nbsp; }<BR>&nbsp;&nbsp; private void scroll (){<BR>&nbsp;&nbsp;&nbsp; …<BR>&nbsp;&nbsp; }<BR>}</P>
<P>　　Decorator确实能够很好的缓解当功能组合过多时子类继承所能够带来的问题。但是在得到很大的灵活性的同时，Decorator在使用时也表现得较为复杂。看看仅仅为了得到一个IO流，除了要创建核心的流外，还要为其加上各种各样的装饰类，这使得代码变得复杂而难懂。有几个人一开始时没有被Java的IO库吓一跳呢？</P>
<P>　　<STRONG>小结：</STRONG></P>
<P>　　Bridge模式用来分离抽象和实现，使得这两个部分能够分别的演化而不必修改另外一部分的内容。通常的，可以在实现部分定义一些基本的原子方法，而在抽象部分则通过组合定义在实现层次中的原子方法来实现系统的功能。Decorator模式通过聚合机制来为对象动态的添加职责，解决了在子类继承中容易引起的子类爆炸的问题。</P>                </TD></TR>              </TBODY>            </TABLE>          </TD></TR>          <TR><TD width=10 height=11><IMG height=11 src='images/u_16.gif' width=10></TD>          <TD style='BORDER-BOTTOM: #e8e8e8 1px solid' width=695 bgColor=#f9f9f9 height=11><IMG height=1 src='' width=1></TD>          <TD width=10 height=11><IMG height=11 src='images/u_17.gif' width=10></TD>          </TR></TBODY>        </TABLE>      </TD></TR></TBODY>    </TABLE>    <BR><div align=right>页面功能&nbsp;      【<a href="javascript:window.external.AddFavorite(location.href,document.title+'－－www.JavaFan.NET');">加入收藏</a>】      【<a href='/sendarticle.jsp?title=从Java类库看设计模式（三）&URL=20051105083932433' onclick="window.open(this.href,'','top=180,left=240,width=342,height=326,scrollbars=yes,resizable=no');return false;">推荐给朋友</a>】      【字体：<a href="javascript:fontZoom(15)" class=black>大</a>&nbsp;<a href="javascript:fontZoom(13)" class=black>中</a>&nbsp;<a href="javascript:fontZoom(12)" class=black>小</a>】      【<a href="javascript:window.close()" class=black>关闭</a>】&nbsp;&nbsp;&nbsp;    </div>    </TD></TR>    <TR><TD vAlign=top><IMG height=12 src='images/u_06.gif' width=751></TD></TR>  </TBODY></TABLE><BR><TABLE cellSpacing=0 cellPadding=0 width=750 align=center border=0>  <TBODY>    <TR><TD bgColor=#cacaca height=1></TD></TR>    <TR><TD vAlign=center align=middle height=30>Copyright &copy; 2003 - 2006 JavaFan.NET All Rights Reserved</TD></TR>  </TBODY></TABLE></body></html>