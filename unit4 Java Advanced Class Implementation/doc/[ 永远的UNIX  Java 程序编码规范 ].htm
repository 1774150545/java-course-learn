<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<title>[ 永远的UNIX > Java 程序编码规范 ]</title>
<style type="text/css">
<!--
body,th,input,select,textarea,select,checkbox{font:12pt 宋体}
A:link { text-decoration:underline; color:#E6A306}
A:visited { text-decoration:underline; color:#E6A306}
A:hover { text-decoration:underline; color:#FFFF00}
body {  font-family: "宋体", "serif"; font-size: 12pt}
td {  font-family: "宋体", "serif"; font-size: 12pt}
p  { font-size: 9pt; line-height: 150%}
-->
</style>
</head>

<body text="#ffffff" background="/images/bline.gif" bgcolor="#000000">
<div align="center"><center>

<table border="0" width="750"  cellspacing="0" cellpadding="0" height="400">
<tr>
  <td height="45"><p align="center"><img src="/images/title.gif" alt="[ 永远的UNIX::UNIX技术资料的宝库 ]"></td>
  </tr> 
<tr>
<tr>
 <td align=left height="40" valign=bottom align=left><small><a href="/">首页</a> > 编程技术 > Java >   正文</small></td>
</tr>
<tr>
  <td width="100%" height="2" colspan="5" bgcolor="#D09F0D"><img src="/images/c.gif" width=1 height=1></td> 
</tr>
<tr>
 <td align=center height="40" valign=middle><font size=5><b>Java 程序编码规范</b></font></td>
</tr>
<tr>
 <td align=center height="20"><font color=#999999><small>本文出自:不详 作者：李小敏 IBM.com (2002-02-01 06:15:00)</small></font></td>
</tr>
<td align=center>
<table border="0" width="700"  cellspacing="0" cellpadding="0" align=center>
<tr><td valign=top>
<font color=#cccccc>&nbsp;&nbsp;&nbsp;&nbsp;所有的程序开发手册都包含了各种规则。一些习惯自由程序人员可能对这些规则很不适<br>应，但是在多个开发人员&nbsp;共同写作的情况下，这些规则是必需的。这不仅仅是为了开<br>发效率来考虑，而且也是为了后期维护考虑。<br><br>命名规范<br>定义这个规范的目的是让项目中所有的文档都看起来像一个人写的，增加可读性，减少<br>项目组中因为换人而带来&nbsp;的损失。（这些规范并不是一定要绝对遵守，但是一定要让<br>程序有良好的可读性）<br><br><br>Package&nbsp;的命名<br>Package&nbsp;的名字应该都是由一个小写单词组成。<br>Class&nbsp;的命名<br>Class&nbsp;的名字必须由大写字母开头而其他字母都小写的单词组成<br>Class&nbsp;变量的命名<br>变量的名字必须用一个小写字母开头。后面的单词用大写字母开头。<br>Static&nbsp;Final&nbsp;变量的命名<br>Static&nbsp;Final&nbsp;变量的名字应该都大写，并且指出完整含义。<br>参数的命名<br>参数的名字必须和变量的命名规范一致。<br>数组的命名<br>数组应该总是用下面的方式来命名：<br><br>byte[]&nbsp;buffer;<br><br><br>而不是：<br><br>byte&nbsp;buffer[];<br><br><br><br>方法的参数<br>使用有意义的参数命名，如果可能的话，使用和要赋值的字段一样的名字：<br><br>SetCounter(int&nbsp;size){<br>this.size&nbsp;=&nbsp;size;<br>}<br><br><br><br><br>Java&nbsp;文件样式<br>所有的&nbsp;Java(*.java)&nbsp;文件都必须遵守如下的样式规则<br><br><br>版权信息<br>版权信息必须在&nbsp;java&nbsp;文件的开头，比如：<br><br>/**<br>*&nbsp;Copyright&nbsp;?&nbsp;2000&nbsp;Shanghai&nbsp;XXX&nbsp;Co.&nbsp;Ltd.<br>*&nbsp;All&nbsp;right&nbsp;reserved.<br>*/<br><br><br>其他不需要出现在&nbsp;javadoc&nbsp;的信息也可以包含在这里。<br><br><br>Package/Imports<br>package&nbsp;行要在&nbsp;import&nbsp;行之前，import&nbsp;中标准的包名要在本地的包名之前，而且按<br>照字母顺序排列。如&nbsp;果&nbsp;import&nbsp;行中包含了同一个包中的不同子目录，则应该用&nbsp;*&nbsp;来<br>处理。<br><br>package&nbsp;hotlava.net.stats;<br><br>import&nbsp;java.io.*;<br>import&nbsp;java.util.Observable;<br>import&nbsp;hotlava.util.Application;<br><br><br>这里&nbsp;java.io.*&nbsp;使用来代替InputStream&nbsp;and&nbsp;OutputStream&nbsp;的。<br><br><br>Class<br>接下来的是类的注释，一般是用来解释类的。<br><br>/**<br>*&nbsp;A&nbsp;class&nbsp;representing&nbsp;a&nbsp;set&nbsp;of&nbsp;packet&nbsp;and&nbsp;byte&nbsp;counters<br>*&nbsp;It&nbsp;is&nbsp;observable&nbsp;to&nbsp;allow&nbsp;it&nbsp;to&nbsp;be&nbsp;watched,&nbsp;but&nbsp;only<br>*&nbsp;reports&nbsp;changes&nbsp;when&nbsp;the&nbsp;current&nbsp;set&nbsp;is&nbsp;complete<br>*/<br><br><br>接下来是类定义，包含了在不同的行的&nbsp;extends&nbsp;和&nbsp;implements<br><br>public&nbsp;class&nbsp;CounterSet<br>extends&nbsp;Observable<br>implements&nbsp;Cloneable<br><br><br><br>Class&nbsp;Fields<br>接下来是类的成员变量：<br><br>/**<br>*&nbsp;Packet&nbsp;counters<br>*/<br>protected&nbsp;int[]&nbsp;packets;<br><br><br>public&nbsp;的成员变量必须生成文档（JavaDoc）。proceted、private和&nbsp;package&nbsp;定义<br>的成员变量如果名字含义明&nbsp;确的话，可以没有注释。<br><br><br>存取方法<br>接下来是类变量的存取的方法。它只是简单的用来将类的变量赋值获取值的话，可以简<br>单的写在一行上。<br><br>/**<br>*&nbsp;Get&nbsp;the&nbsp;counters<br>*&nbsp;@return&nbsp;an&nbsp;array&nbsp;containing&nbsp;the&nbsp;statistical&nbsp;data.&nbsp;This&nbsp;array&nbsp;has&nbsp;been<br>*&nbsp;freshly&nbsp;allocated&nbsp;and&nbsp;can&nbsp;be&nbsp;modified&nbsp;by&nbsp;the&nbsp;caller.<br>*/<br>public&nbsp;int[]&nbsp;getPackets()&nbsp;{&nbsp;return&nbsp;copyArray(packets,&nbsp;offset);&nbsp;}<br>public&nbsp;int[]&nbsp;getBytes()&nbsp;{&nbsp;return&nbsp;copyArray(bytes,&nbsp;offset);&nbsp;}<br><br>public&nbsp;int[]&nbsp;getPackets()&nbsp;{&nbsp;return&nbsp;packets;&nbsp;}<br>public&nbsp;void&nbsp;setPackets(int[]&nbsp;packets)&nbsp;{&nbsp;this.packets&nbsp;=&nbsp;packets;&nbsp;}<br><br><br>其它的方法不要写在一行上<br><br><br>构造函数<br>接下来是构造函数，它应该用递增的方式写（比如：参数多的写在后面）。<br>访问类型&nbsp;("public",&nbsp;"private"&nbsp;等.)&nbsp;和&nbsp;任何&nbsp;"static",&nbsp;"final"&nbsp;或&nbsp;"synchronized"&nbsp;<br>应该在一行中，并且&nbsp;方法和参数另写一行，这样可以使方法和参数更易读。<br><br>public<br>CounterSet(int&nbsp;size){<br>this.size&nbsp;=&nbsp;size;<br>}<br><br><br><br>克隆方法<br>如果这个类是可以被克隆的，那么下一步就是&nbsp;clone&nbsp;方法：<br><br>public<br>Object&nbsp;clone()&nbsp;{<br>try&nbsp;{<br>CounterSet&nbsp;obj&nbsp;=&nbsp;(CounterSet)super.clone();<br>obj.packets&nbsp;=&nbsp;(int[])packets.clone();<br>obj.size&nbsp;=&nbsp;size;<br>return&nbsp;obj;<br>}catch(CloneNotSupportedException&nbsp;e)&nbsp;{<br>throw&nbsp;new&nbsp;InternalError("Unexpected&nbsp;CloneNotSUpportedException:&nbsp;"&nbsp;+&nbsp;e.getMessage());<br>}<br>}<br><br><br><br>类方法<br>下面开始写类的方法：<br><br>/**<br>*&nbsp;Set&nbsp;the&nbsp;packet&nbsp;counters<br>*&nbsp;(such&nbsp;as&nbsp;when&nbsp;restoring&nbsp;from&nbsp;a&nbsp;database)<br>*/<br>protected&nbsp;final<br>void&nbsp;setArray(int[]&nbsp;r1,&nbsp;int[]&nbsp;r2,&nbsp;int[]&nbsp;r3,&nbsp;int[]&nbsp;r4)<br>throws&nbsp;IllegalArgumentException<br>{<br>//<br>//&nbsp;Ensure&nbsp;the&nbsp;arrays&nbsp;are&nbsp;of&nbsp;equal&nbsp;size<br>//<br>if&nbsp;(r1.length&nbsp;!=&nbsp;r2.length&nbsp;||&nbsp;r1.length&nbsp;!=&nbsp;r3.length&nbsp;||&nbsp;r1.length&nbsp;!=&nbsp;r4.length)<br>throw&nbsp;new&nbsp;IllegalArgumentException("Arrays&nbsp;must&nbsp;be&nbsp;of&nbsp;the&nbsp;same&nbsp;size");<br>System.arraycopy(r1,&nbsp;0,&nbsp;r3,&nbsp;0,&nbsp;r1.length);<br>System.arraycopy(r2,&nbsp;0,&nbsp;r4,&nbsp;0,&nbsp;r1.length);<br>}<br><br><br><br><br>toString&nbsp;方法<br>无论如何，每一个类都应该定义&nbsp;toString&nbsp;方法：<br><br>public<br>String&nbsp;toString()&nbsp;{<br>String&nbsp;retval&nbsp;=&nbsp;"CounterSet:&nbsp;";<br>for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;data.length();&nbsp;i++)&nbsp;{<br>retval&nbsp;+=&nbsp;data.bytes.toString();<br>retval&nbsp;+=&nbsp;data.packets.toString();<br>}<br>return&nbsp;retval;<br>}<br>}<br><br><br><br>main&nbsp;方法<br>如果main(String[])&nbsp;方法已经定义了,&nbsp;那么它应该写在类的底部.<br><br>代码编写格式<br><br><br>代码样式<br>代码应该用&nbsp;unix&nbsp;的格式，而不是&nbsp;windows&nbsp;的（比如：回车变成回车+换行）<br>文档化<br>必须用&nbsp;javadoc&nbsp;来为类生成文档。不仅因为它是标准，这也是被各种&nbsp;java&nbsp;编译器都<br>认可的方法。使&nbsp;用&nbsp;@author&nbsp;标记是不被推荐的，因为代码不应该是被个人拥有的。<br>缩进<br>缩进应该是每行2个空格.&nbsp;不要在源文件中保存Tab字符.&nbsp;在使用不同的源代码管理工具<br>时Tab字符将因为用户设&nbsp;置的不同而扩展为不同的宽度.<br>如果你使用&nbsp;UltrEdit&nbsp;作为你的&nbsp;Java&nbsp;源代码编辑器的话，你可以通过如下操作来禁止<br>保存Tab字符,&nbsp;方法是通&nbsp;过&nbsp;UltrEdit中先设定&nbsp;Tab&nbsp;使用的长度室2个空格，然后用&nbsp;<br>Format|Tabs&nbsp;to&nbsp;Spaces&nbsp;菜单将&nbsp;Tab&nbsp;转换为空格。<br>页宽<br>页宽应该设置为80字符.&nbsp;源代码一般不会超过这个宽度,&nbsp;并导致无法完整显示,&nbsp;但这一设<br>置也可以灵活调整.&nbsp;在&nbsp;任何情况下,&nbsp;超长的语句应该在一个逗号或者一个操作符后折行.&nbsp;<br>一条语句折行后,&nbsp;应该比原来的语句再缩进2&nbsp;个字符.<br>{}&nbsp;对<br>{}&nbsp;中的语句应该单独作为一行.&nbsp;例如,&nbsp;下面的第1行是错误的,&nbsp;第2行是正确的:<br><br>if&nbsp;(i&gt;0)&nbsp;{&nbsp;i&nbsp;++&nbsp;};&nbsp;//&nbsp;错误,&nbsp;{&nbsp;和&nbsp;}&nbsp;在同一行<br><br>if&nbsp;(i&gt;0)&nbsp;{<br>i&nbsp;++<br>};&nbsp;//&nbsp;正确,&nbsp;{&nbsp;单独作为一行<br><br><br>}&nbsp;语句永远单独作为一行.<br><br><br>如果&nbsp;}&nbsp;语句应该缩进到与其相对应的&nbsp;{&nbsp;那一行相对齐的位置。<br><br><br>括号<br>左括号和后一个字符之间不应该出现空格,&nbsp;同样,&nbsp;右括号和前一个字符之间也不应该出<br>现空格.&nbsp;下面的例子说明&nbsp;括号和空格的错误及正确使用:<br><br>CallProc(&nbsp;AParameter&nbsp;);&nbsp;//&nbsp;错误<br>CallProc(AParameter);&nbsp;//&nbsp;正确<br><br>不要在语句中使用无意义的括号.&nbsp;括号只应该为达到某种目的而出现在源代码中。下面<br>的例子说明错误和正确的&nbsp;用法:<br><br>if&nbsp;((I)&nbsp;=&nbsp;42)&nbsp;{&nbsp;//&nbsp;错误&nbsp;-&nbsp;括号毫无意义<br>if&nbsp;(I&nbsp;==&nbsp;42)&nbsp;or&nbsp;(J&nbsp;==&nbsp;42)&nbsp;then&nbsp;//&nbsp;正确&nbsp;-&nbsp;的确需要括号<br><br><br>程序编写规范<br><br><br>exit()<br>exit&nbsp;除了在&nbsp;main&nbsp;中可以被调用外，其他的地方不应该调用。因为这样做不给任何代码<br>代码机会来截获退出。&nbsp;一个类似后台服务地程序不应该因为某一个库模块决定了要退出<br>就退出。<br>异常<br>申明的错误应该抛出一个RuntimeException或者派生的异常。<br>顶层的main()函数应该截获所有的异常，并且打印（或者记录在日志中）在屏幕上。<br>垃圾收集<br>JAVA使用成熟的后台垃圾收集技术来代替引用计数。但是这样会导致一个问题：你必须在<br>使用完对象的实例以后&nbsp;进行清场工作。比如一个prel的程序员可能这么写：<br><br>...<br>{<br>FileOutputStream&nbsp;fos&nbsp;=&nbsp;new&nbsp;FileOutputStream(projectFile);<br>project.save(fos,&nbsp;"IDE&nbsp;Project&nbsp;File");<br>}<br>...<br><br><br>除非输出流一出作用域就关闭，非引用计数的程序语言，比如JAVA，是不能自动完成变<br>量的清场工作的。必须象&nbsp;下面一样写：<br><br>FileOutputStream&nbsp;fos&nbsp;=&nbsp;new&nbsp;FileOutputStream(projectFile);<br>project.save(fos,&nbsp;"IDE&nbsp;Project&nbsp;File");<br>fos.close();<br><br><br><br>Clone<br>下面是一种有用的方法：<br><br>implements&nbsp;Cloneable<br><br>public<br>Object&nbsp;clone()<br>{<br>try&nbsp;{<br>ThisClass&nbsp;obj&nbsp;=&nbsp;(ThisClass)super.clone();<br>obj.field1&nbsp;=&nbsp;(int[])field1.clone();<br>obj.field2&nbsp;=&nbsp;field2;<br>return&nbsp;obj;<br>}&nbsp;catch(CloneNotSupportedException&nbsp;e)&nbsp;{<br>throw&nbsp;new&nbsp;InternalError("Unexpected&nbsp;CloneNotSUpportedException:&nbsp;"&nbsp;+&nbsp;e.getMessage());<br>}<br>}<br><br><br><br>final&nbsp;类<br>绝对不要因为性能的原因将类定义为&nbsp;final&nbsp;的（除非程序的框架要求）<br>如果一个类还没有准备好被继承，最好在类文档中注明，而不要将她定义为&nbsp;final&nbsp;的。<br>这是因为没有人可以保&nbsp;证会不会由于什么原因需要继承她。<br>访问类的成员变量<br>大部分的类成员变量应该定义为&nbsp;protected&nbsp;的来防止继承类使用他们。<br>注意，要用"int[]&nbsp;packets"，而不是"int&nbsp;packets[]"，后一种永远也不要用。<br><br>public&nbsp;void&nbsp;setPackets(int[]&nbsp;packets)&nbsp;{&nbsp;this.packets&nbsp;=&nbsp;packets;&nbsp;}<br><br>CounterSet(int&nbsp;size)<br>{<br>this.size&nbsp;=&nbsp;size;<br>}<br><br><br><br><br>编程技巧<br><br><br>byte&nbsp;数组转换到&nbsp;characters<br>为了将&nbsp;byte&nbsp;数组转换到&nbsp;characters，你可以这么做：<br><br>"Hello&nbsp;world!".getBytes();<br><br><br>Utility&nbsp;类<br>Utility&nbsp;类（仅仅提供方法的类）应该被申明为抽象的来防止被继承或被初始化。<br><br><br>初始化<br>下面的代码是一种很好的初始化数组的方法：<br><br>objectArguments&nbsp;=&nbsp;new&nbsp;Object[]&nbsp;{&nbsp;arguments&nbsp;};<br><br><br>枚举类型<br>JAVA&nbsp;对枚举的支持不好，但是下面的代码是一种很有用的模板：<br><br>class&nbsp;Colour&nbsp;{<br>public&nbsp;static&nbsp;final&nbsp;Colour&nbsp;BLACK&nbsp;=&nbsp;new&nbsp;Colour(0,&nbsp;0,&nbsp;0);<br>public&nbsp;static&nbsp;final&nbsp;Colour&nbsp;RED&nbsp;=&nbsp;new&nbsp;Colour(0xFF,&nbsp;0,&nbsp;0);<br>public&nbsp;static&nbsp;final&nbsp;Colour&nbsp;GREEN&nbsp;=&nbsp;new&nbsp;Colour(0,&nbsp;0xFF,&nbsp;0);<br>public&nbsp;static&nbsp;final&nbsp;Colour&nbsp;BLUE&nbsp;=&nbsp;new&nbsp;Colour(0,&nbsp;0,&nbsp;0xFF);<br>public&nbsp;static&nbsp;final&nbsp;Colour&nbsp;WHITE&nbsp;=&nbsp;new&nbsp;Colour(0xFF,&nbsp;0xFF,&nbsp;0xFF);<br>}<br><br><br>这种技术实现了RED,&nbsp;GREEN,&nbsp;BLUE&nbsp;等可以象其他语言的枚举类型一样使用的常量。&nbsp;<br>他们可以用&nbsp;'=='&nbsp;操作符来&nbsp;比较。<br>但是这样使用有一个缺陷：如果一个用户用这样的方法来创建颜色&nbsp;BLACK<br><br>new&nbsp;Colour(0,0,0)<br><br>那么这就是另外一个对象，'=='操作符就会产生错误。她的&nbsp;equal()&nbsp;方法仍然有效。<br>由于这个原因，这个技术&nbsp;的缺陷最好注明在文档中，或者只在自己的包中使用。<br><br>Swing<br><br><br>避免使用&nbsp;AWT&nbsp;组件<br>混合使用&nbsp;AWT&nbsp;和&nbsp;Swing&nbsp;组件<br>如果要将&nbsp;AWT&nbsp;组件和&nbsp;Swing&nbsp;组件混合起来使用的话，请小心使用。实际上，尽量不<br>要将他们混合起来使用。<br><br><br>滚动的&nbsp;AWT&nbsp;组件<br>AWT&nbsp;组件绝对不要用&nbsp;JscrollPane&nbsp;类来实现滚动。滚动&nbsp;AWT&nbsp;组件的时候一定要用&nbsp;<br>AWT&nbsp;ScrollPane&nbsp;组件来实&nbsp;现。<br><br><br>避免在&nbsp;InternalFrame&nbsp;组件中使用&nbsp;AWT&nbsp;组件<br>尽量不要这么做，要不然会出现不可预料的后果。<br><br><br>Z-Order&nbsp;问题<br>AWT&nbsp;组件总是显示在&nbsp;Swing&nbsp;组件之上。当使用包含&nbsp;AWT&nbsp;组件的&nbsp;POP-UP&nbsp;菜单的时候要<br>小心，尽量不要这样使&nbsp;用。<br><br><br><br>调试<br><br><br>调试在软件开发中是一个很重要的部分，存在软件生命周期的各个部分中。调试能够用<br>配置开、关是最基本&nbsp;的。<br><br>很常用的一种调试方法就是用一个&nbsp;PrintStream&nbsp;类成员，在没有定义调试流的时候就为<br>&nbsp;null，类要定义一&nbsp;个&nbsp;debug&nbsp;方法来设置调试用的流。<br><br><br><br>性能<br><br><br>在写代码的时候，从头至尾都应该考虑性能问题。这不是说时间都应该浪费在优化代码上，<br>而是我们时刻应该提&nbsp;醒自己要注意代码的效率。比如：如果没有时间来实现一个高效的<br>算法，那么我们应该在文档中记录下来，以便&nbsp;在以后有空的时候再来实现她。<br><br>不是所有的人都同意在写代码的时候应该优化性能这个观点的，他们认为性能优化的问题<br>应该在项目的后期再去&nbsp;考虑，也就是在程序的轮廓已经实现了以后。<br>不必要的对象构造<br>不要在循环中构造和释放对象<br><br><br>使用&nbsp;StringBuffer&nbsp;对象<br>在处理&nbsp;String&nbsp;的时候要尽量使用&nbsp;StringBuffer&nbsp;类，StringBuffer&nbsp;类是构成&nbsp;String&nbsp;类<br>的基础。String&nbsp;类&nbsp;将&nbsp;StringBuffer&nbsp;类封装了起来，（以花费更多时间为代价）为开发<br>人员提供了一个安全的接口。当我们在构造&nbsp;字符串的时候，我们应该用&nbsp;StringBuffer&nbsp;<br>来实现大部分的工作，当工作完成后将&nbsp;StringBuffer&nbsp;对象再转换为&nbsp;需要的&nbsp;String&nbsp;对象。<br>比如：如果有一个字符串必须不断地在其后添加许多字符来完成构造，那么我们应该使&nbsp;<br>用&nbsp;StringBuffer&nbsp;对象和她的&nbsp;append()&nbsp;方法。如果我们用&nbsp;String&nbsp;对象代替&nbsp;StringBuffer&nbsp;<br>对象的话，会花费&nbsp;许多不必要的创建和释放对象的&nbsp;CPU&nbsp;时间。<br><br>避免太多的使用&nbsp;synchronized&nbsp;关键字<br>避免不必要的使用关键字&nbsp;synchronized，应该在必要的时候再使用她，这是一个避免死<br>锁的好方法。<br><br>可移植性<br>Borland&nbsp;Jbulider&nbsp;不喜欢&nbsp;synchronized&nbsp;这个关键字，如果你的断点设在这些关键字的<br>作用域内的话，调试的&nbsp;时候你会发现的断点会到处乱跳，让你不知所措。除非必须，尽<br>量不要使用。<br><br><br>换行<br>如果需要换行的话，尽量用&nbsp;println&nbsp;来代替在字符串中使用"\n"。<br>你不要这样：<br><br>System.out.print("Hello,world!\n");<br><br>要这样：<br><br>System.out.println("Hello,world!");<br><br>或者你构造一个带换行符的字符串，至少要象这样：<br><br>String&nbsp;newline&nbsp;=&nbsp;System.getProperty("line.separator");<br>System.out.println("Hello&nbsp;world"&nbsp;+&nbsp;newline);<br><br><br>PrintStream<br>PrintStream&nbsp;已经被不赞成（deprecated）使用，用&nbsp;PrintWrite&nbsp;来代替她。<br><br>参考资料<br><br>查找有关&nbsp;Thread&nbsp;类和&nbsp;Java&nbsp;2&nbsp;平台，标准版，API&nbsp;规范的其他方面的信息。&nbsp;<br><br><br>	
(<a href=http://www.fanqiang.com>http://www.fanqiang.com</a>)
</font>
&nbsp;&nbsp;&nbsp;&nbsp;进入【<a href=http://www.chinaunix.net>ChinaUnix.net论坛</a>】
</td>
</tr>
<tr>
<td><hr></td>
</tr>
<tr>
<td><b>相关文章</b> </td>
</tr>
<tr>
<td></td>
</tr>
<tr>
<tr>
<td></td>
</tr>
<td>&nbsp;</td>
</tr>
</table>
</td>
</tr>
<tr>
  <td width="100%" height="2" colspan="5" bgcolor="#D09F0D"><img src="/images/c.gif" width=1 height=1></td> 
</tr>
<tr>
    <td width="100%" height="40" colspan="5" valign=top><p align="center"><font color=#ffffff>★&nbsp;&nbsp;樊强制作 欢迎分享&nbsp;&nbsp;★ </font></p></td>
  </tr>
</table>
</center></div>
</body>
</html>
